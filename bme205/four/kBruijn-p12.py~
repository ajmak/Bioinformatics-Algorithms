#!/usr/bin/env python3
#Name: Allysia Mak (amak)
#Group Members: none

"""

Input: 
Output:
"""

import argparse
import sys

class CommandLine():
    """ Parses command line argument for kmer length"""
    def __init__(self):
        #adapted from David Bernick's program.py skeleton code and http://docs.python.org/2/library/argparse.html
        self.parser = argparse.ArgumentParser()
        self.parser.add_argument('-k', nargs='?', default=3, type=int, help='Set kmer length, default=3')
        self.args = self.parser.parse_args()
        

class DeBruijn:
    """ Constructs the de Bruijn graph of a string for kMer length -k """
    def __init__(self, seqStr, args):
        self.seqStr = seqStr
        self.args = args
        self.k = args.k
        
    def getkMers(self):
        """ Finds and organizes all kMers in a sequence into an adjacency list and returns as a sorted list """

        adjacencyDict = self.slideSeq()
        
        #https://stackoverflow.com/questions/32081729/how-to-sort-dictionary-on-first-element-of-the-key-tuple
        sortedkList = sorted(adjacencyDict.items())
        return sortedkList
    def slideSeq(self):
        """ Slides across sequence stores beginning and end of each kMer as an adjacency list """
        nodesDict = {}
        for x in range(len(self.seqStr)-self.k):
            pre = self.seqStr[x:self.k+x-1]
            end = self.seqStr[x+1:self.k+x]
            if pre in nodesDict.keys():
                nodesDict[pre].append(end)
            else:
                nodesDict[pre] = [end]

        return nodesDict


def main():
    """"""
    arguments = CommandLine()
    seqStr = sys.stdin.readlines()

    for seq in seqStr:
        graphKmers = DeBruijn(seq, arguments.args)
        graphList = graphKmers.getkMers()
        for kMer in graphList:
            print(kMer)

if __name__== "__main__":
    main()
#list is number of edges associated with a node
#stop when all are included, each one has to be used once
