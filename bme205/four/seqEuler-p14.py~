#!/usr/bin/env python3
#Name: Allysia Mak (amak)
#Group Members: none

"""
Finds Eulerian path of given directed nodes 
Input: A directed path containing a Eulerian path
Output: The Eulerian path 
Algorithm from: http://www.graph-magics.com/articles/euler.php
"""

import argparse
import sys
from collections import defaultdict

class CommandLine():
    """ Parses command line argument for kmer length"""
    def __init__(self):
        #adapted from David Bernick's program.py skeleton code and http://docs.python.org/2/library/argparse.html
        self.parser = argparse.ArgumentParser()
        self.parser.add_argument('-k', nargs='?', default=3, type=int, help='Set kmer length, default=3')
        self.args = self.parser.parse_args()


class EulerianPath:
    """ Constructs the de Bruijn graph of a string for kMer length -k """
    def __init__(self, kMers, k):
        self.kMers = kMers
        self.k = k
        self.stack = []

    def buildaBruijn(self):
        """ Finds and organizes all kMers in a list into an adjacency list and returns as a sorted list """
        nodesDict = {}
        for x in self.kMers:
            pre = x[:-1].strip()
            end = x[1:].strip()
            if pre in nodesDict.keys():
                nodesDict[pre].append(end)
            else:
                nodesDict[pre] = [end]
        # sorts lists within dictionary for nodes with multiple edges 
        sortnodesDict = {x:sorted(nodesDict[x]) for x in nodesDict.keys()}
        # sorts output list based on prefix node                   
        orderList = sorted(sortnodesDict.items())
        return orderList, sortnodesDict


    def getEdges(self, deBruijn):
        """ Slides across sequence stores beginning and end of each kMer as an adjacency list """
        inCount = {}
        outCount = {}
        edgesDict = {}
        maxOut = 0
        isPath = False
        for each in self.dirGraph:

            outNode = each.split('-')[0].rstrip()
            inNode = each.split('>')[1].strip()
            # stores incoming and outgoing edges for each node
            if outNode not in outCount.keys(): outCount[outNode] = 0
            if outNode not in inCount.keys(): inCount[outNode] = 0
            if ',' in inNode:
                nodesIn = inNode.split(',')
                edgesDict[outNode] = nodesIn
                for nodes in nodesIn:
                    if nodes not in inCount.keys(): inCount[nodes] = 1
                    else: inCount[nodes] += 1
                    if nodes not in outCount.keys(): outCount[nodes] = 0
                    outCount[outNode] += 1

            else:
                outCount[outNode] += 1
                edgesDict[outNode] = [inNode]
                if inNode not in inCount.keys(): inCount[inNode] = 1
                else: inCount[inNode] += 1
                if inNode not in outCount.keys(): outCount[inNode] = 0

        # finds starting node if Eulerian path
        for key in outCount.keys():
            if outCount[key] > inCount[key]:
                isPath = True
                curIn = key
        # chooses a random node in the dict if it is an Eulerian cycle
        if isPath == False:
            curIn = outCount[0]
        return edgesDict, curIn

    def traversePath(self, edgeDict, firstIn):
        curNode = firstIn
        finalPath = []
        # while stack is not empty or dictionary of edges is not empty
        while len(self.stack) != 0 or len(edgeDict[curNode]) != 0:
            if curNode not in edgeDict.keys() or not edgeDict[curNode]:
                finalPath.append(curNode)
                curNode = self.stack.pop()
                continue
            self.stack.append(curNode)
            prevNode = curNode
            curNode = edgeDict[curNode][0]
            del edgeDict[prevNode][0]
        finalPath.append(curNode)
        return finalPath

def main():
    arguments = CommandLine()
    k = arguments.args.k
    kMers = sys.stdin.readlines()
    graphKmers = EulerianPath(kMers, k)
    deBruijn = graphKmers.buildaBruijn()
    print(deBruijn)
    edgeDict, firstIn = graphKmers.getEdges(deBruijn)
    graphList = graphKmers.traversePath(edgeDict, firstIn)

    graphList.reverse()
    print('->'.join(graphList))
    

if __name__== "__main__":
    main()

